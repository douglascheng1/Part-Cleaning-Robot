#include <Servo.h>
#include <EEPROM.h>
#include <uSTimer2.h>
#include <CharliePlexM.h>
#include <Wire.h>
#include <I2CEncoder.h>
#include <MPU6050_tockn.h>

Servo servo_RightMotor;
Servo servo_LeftMotor;

MPU6050 mpu6050(Wire);

const int motor_Right = 11;
const int motor_Left = 10;
long Prev_Left_Motor_Position;
long Curr_Left_Motor_Position;

double initAngle; //initial angle of compass to be stored
double currAngle; // will store current angle of compass to compare to initial angle
boolean setInitAngle=false; 
double angleOffset=3; //may need to adjust based on testing
double currDirection;
double north;
double south;
boolean turnside=false;
boolean turnfront=false;
boolean IR_side_seen=false;
boolean IR_front_seen=false;


unsigned long prevMillis=0;
unsigned long currentMillis=0;
unsigned long US_timer=0;
unsigned long prev_US_timer=0;
int returnTimer = 30000

void setup() {
  Wire.begin();
  Serial.begin(9600);
  mpu6050.begin();
 //
  mpu6050.calcGyroOffsets(true);
  initAngle=mpu6050.getAngleZ();
  north=initAngle+270;
  south=initAngle+90;
  currDirection=north;
  



}

void loop() {

 
  currentMillis=millis();
  mpu6050.update();
  Serial.print("\tangleZ : ");
  Serial.println(mpu6050.getAngleZ());
  currAngle=mpu6050.getAngleZ();
  if (currAngle<0)
  {
    currAngle=currAngle+(((int(currAngle))%360)*-360)+360;
  }
  if (currAngle>360)
  {
    currAngle=currAngle-(((int(currAngle))%360)*360);
  }
  Serial.println(currAngle);

  if ((currentMillis-prevMillis)>returnTimer)
  {
    if (currAngle<=360&&currAngle>=180)//after obstacles are navigated around robot will continue in northern direction
    {
      currDirection=north;
      if(currAngle>270+angleOffset)
      {
        servo_RightMotor.writeMicroseconds(1300);
        servo_LeftMotor.writeMicroseconds(1700);
        
      }
      else if (currAngle<270-angleOffset)
      {
        servo_LeftMotor.writeMicroseconds(1300);
        servo_RightMotor.writeMicroseconds(1700);
       
      }   
      else if (currAngle<270+angleOffset&&currAngle>270-angleOffset)
      {
        servo_LeftMotor.writeMicroseconds(1600);
        servo_RightMotor.writeMicroseconds(1600);
        turnside = true;
      }
      
    }
    else 
    {
      currDirection=south;
      if (currAngle>90+angleOffset)
      {
        servo_LeftMotor.writeMicroseconds(1300);
        servo_RightMotor.writeMicroseconds(1700);
      }
      else if (currAngle<90-angleOffset)
      {
        servo_RightMotor.writeMicroseconds(1300):
        servo_LeftMotor.writeMicroseconds(1700);
      }
      else if (currAngle<90+angleOffset&&currAngle>90-angleOffset)
      {
        turnside=true;
      }
    }
    if (currDirection==north&&turnside==true)
    {
      //IR Ping
      if (IRSensor=seen)
      {
        IR_side_seen=true;
      }
      if (IR_side_seen==true)
      {
        if(currAngle>initAngle+180+angleOffset)
        {
          servo_RightMotor.writeMicroseconds(1300);
          servo_LeftMotor.writeMicroseconds(1700);
        }
        else if (currAngle>initAngle+180-angleOffset&&currAngle<initAngle+180+angleOffset)
        {
          servo_RightMotor.writeMicroseconds(1600);
          servo_LeftMotor.writeMicroseconds(1600);
          turnfront=true;
        }
      }
      else
      {
        servo_RightMotor.writeMicroseconds(1600):
        servo_LeftMotor.writeMicroseconds(1600);
      }
    }
    else if (currDirection==south&&turnside=true)
    {
      //IR Ping
      if (IRSensor=seen)
      {
        IR_side_seen=true;
      }
      if (IR_side_seen==true)
      {
        if(currAngle>initAngle+180+angleOffset)
        {
          servo_RightMotor.writeMicroseconds(1700);
          servo_LeftMotor.writeMicroseconds(1300);
        }
        else if (currAngle>initAngle+180-angleOffset&&currAngle<initAngle+180+angleOffset)
        {
          servo_RightMotor.writeMicroseconds(1600);
          servo_LeftMotor.writeMicroseconds(1600);
          turnfront=true;
        }
      }
      else
      {
        servo_RightMotor.writeMicroseconds(1600):
        servo_LeftMotor.writeMicroseconds(1600);
      }
      
    }
    if(turnfront==true)
  {
      if (IR_CHECK_FRONT==true)
      {
        servo_RightMotor.writeMicroseconds(1600);
        servo_LeftMotor.writeMicroseconds(1600);
      }
     else
     {
       
       if (currDirection==north)
        {
         if(!(currAngle>north-angleOffset&&currAngle<north+angleOffset))
         servo_LeftMotor.writeMicroseconds(1300);
         servo_RightMotor.writeMicroseconds(1700);
         else
         {
          turnfront=false;
          turnside=true;
         }
         
        }
        else
        {
          if(!(currAngle<south+angleOffset&&currAngle>south-angleOffset))
          {
            servo_RightMotor.writeMicroseconds(1300);
            servo_LeftMotor.writeMicroseconds(1700);
          }
          else
          {
            turnfront=false;
            turnside=true;
          }
          /*if (US_sensor value = prev US_sensor value)
          {
            US_timer=millis();
            if(prev_US_timer=0)
            {
            prev_US_timer=millis();
            }
            if (US_timer-prev_US_timer>1000)
            {
            180 degree turn
            }*/ //for US on back
        
       }
     }
    }
 
  }
