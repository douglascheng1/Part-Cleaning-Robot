#include <Servo.h>
#include <EEPROM.h>
#include <uSTimer2.h>
#include <CharliePlexM.h>
#include <Wire.h>
#include <I2CEncoder.h>
#include <MPU6050_tockn.h>

Servo servo_RightMotor;
Servo servo_LeftMotor;

MPU6050 mpu6050(Wire);

const int motor_Right = 11;
const int motor_Left = 10;
long Prev_Left_Motor_Position;
long Curr_Left_Motor_Position;

double initAngle; //initial angle of compass to be stored
double currAngle; // will store current angle of compass to compare to initial angle
boolean setInitAngle=false; 
double angleOffset=3; //may need to adjust based on testing
double currDirection;
double north;
double south;
boolean turnside=false;
boolean turnfront=false;

unsigned long prevMillis=0;
unsigned long currentMillis=0;
int returnTimer = 30000

void setup() {
  Wire.begin();
  Serial.begin(9600);
  mpu6050.begin();
 //
  mpu6050.calcGyroOffsets(true);
  initAngle=mpu6050.getAngleZ();
  north=initAngle+270;
  south=initAngle+90;
  currDirection=north;
  



}

void loop() {

 
  currentMillis=millis();
  mpu6050.update();
  Serial.print("\tangleZ : ");
  Serial.println(mpu6050.getAngleZ());
  currAngle=mpu6050.getAngleZ();
  if (currAngle<0)
  {
    currAngle=currAngle+(((int(currAngle))%360)*-360)+360;
  }
  if (currAngle>360)
  {
    currAngle=currAngle-(((int(currAngle))%360)*360);
  }

  if ((currentMillis-prevMillis)>returnTimer)
  {
    if (currAngle<=360&&currAngle>=180)//after obstacles are navigated around robot will continue in northern direction
    {
      currDirection=north;
      if turnside=true;
      {
      if(currAngle>270+angleOffset)
      {
        servo_RightMotor.writeMicroseconds(1300);
        servo_LeftMotor.writeMicroseconds(1700);
        
      }
      else if (currAngle<270-angleOffset)
      {
        servo_LeftMotor.writeMicroseconds(1300);
        servo_RightMotor.writeMicroseconds(1700);
       
      }   
      }
    }
    else 
    {
      currDirection=south;
      if (turnside=true)
      if (currAngle>90+angleOffset)
      {
        servo_LeftMotor.writeMicroseconds(1300);
        servo_RightMotor.writeMicroseconds(1700);
        turnside=true;
      }
      else if (currAngle<90-angleOffset)
      {
        servo_RightMotor.writeMicroseconds(1300):
        servo_LeftMotor.writeMicroseconds(1700);
        turnside=true;
      }
    }
    if (currDirection==north&&IRSensor=true)
    {
      if(currAngle>initAngle+177)
      {
        servo_RightMotor.writeMicroseconds(1300);
        servo_LeftMotor.writeMicroseconds(1700);
      }
      turnfront=true;
      turnside=false
    }
    if (currDirection==south&&//IR_Check_Left==true)
    {
      if (currAngle<initAngle+183)
      {
        servo_RightMotor.writeMicroseconds(1700);
        servo_LeftMotor.writeMicroseconds(1300);
      }
      turnfront=true;
      turnside=false
      
    }
    if(turnfront==true)
  {
      if (IR_CHECK_FRONT==true)
      {
        //keep going straight
      }
     else
     {
       
       if (currDirection==north)
        {
         if(!(currAngle>north-angleOffset&&currAngle<north+angleOffset))
         servo_LeftMotor.writeMicroseconds(1300);
         servo_RightMotor.writeMicroseconds(1700);
         else
         {
          turnfront=false;
          turnside=true;
         }
         
        }
        else
        {
          if(!(currAngle<south+angleOffset&&currAngle>south-angleOffset))
          {
            servo_RightMotor.writeMicroseconds(1300);
            servo_LeftMotor.writeMicroseconds(1700);
          }
          else
          {
            turnfront=false;
            turnside=true;
          }
        
       }
     }
    }
 
  }
     

}
